# SSE in Spring
현재 해결해야할 프로젝트의 요구사항으로는 음악 플레이어 서비스를 구축함에 있어 웹 소켓(WebSocket)이 더 적합하지 않은가? 라는 생각을 했었다.

현재 음악 플레이어라는 요구사항을 도출하였을 때, 방장만 오직 재생과 일시정지 그리고 시간 이동을 할 수 있게 권한 처리를 할 예정이기에,
해당 부분은 API로서 전달받고 SSE를 통해 해당 방의 사용자들에게 이벤트처리를 하는 것이 더욱 맞다고 생각하였다.

Server Send Event를 Spring에서 구현하는 대표적인 방법으로 두가지가 존재한다.

첫 번째로는 SeeEimitter를 사용한는 방법이고 두 번째로는 Webflux를 사용하는 방법이 존재한다.

1. SseEmitter
   - Spring에서 SSE를 처리하는 가장 기본적인 방법이다.
   - 단일 스레드를 통해 처리하기에, 비동기 요청처리를 지원한다.
   - 하지만 SseEmitter는 기본적으로 블로킹 방식으로 동작하기 때문에, 요청당 하나의 스레드를 소비하게 된다. 따라서 많은 클라이언트 연결이 있을 경우 스레드 풀이 과도하게 사용될 수 있다.
   - 또한 SseEmitter는 WebFlux와 달리 리액티브 프로그래밍 모델을 지원하지 않기 때문에, 복잡한 비동기 요청 처리가 필요한 경우에는 불편한 점이 존재.

1-1. SseEmitter의 장점
   - 쉽게 구현할 수 있다.
   - 작은 규모의 처리에 적합하다.

1-2. SseEmitter 단점
   - 블로킹 방식으로 동작하여 스레드를 많이 사용하므로 많은 동시 접속이 예상되는 상황에서는 성능 저하 가능성.
   - 리액티브 프로그래밍 모델을 지원하지 않아 비동기 처리가 불편하다.

2. WebFlux
   - Spring 5 이상 버전에서 추가 리액티브 프로그래밍 프레임워크로 비동기 처리와 대량의 처리에 장점
   - 비동기 및 논블로킹 방식으로 SSE를 처리하며, Netty와 함께 사용된다.
   - 높은 확장성과 성능을 가질 수 있으며, 하나의 스레드로 수천 개의 연결을 동시에 처리할 수 있는 장점이 존재한다.
     - 즉, 많은 수의 사용자들이 동시에 접속할 도메인에 적합하다.
   - 비동기 로직을 쉽게 구현이 가능하다.

2-1. WebFlux 장점
- 비동기 및 논블로킹 방식으로 동작하여 높은 확장성과 성능을 제공
- 리액티브 프로그래밍 모델을 지원하여 더 간결하게 코드를 작성할 수 있다.
- 동시 접속 처리에 최적화

2-2. WebFlux 단점
- 리액티브 프로그래밍의 익숙치 않을 경우 코드 작성이 힘들다